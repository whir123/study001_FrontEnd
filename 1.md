

Ajax
AJAX（全称：Asynchronous JavaScript and XML，异步JavaScript与XML），是一种在不重新加载整个网页的情况下，可以与服务器交换数据并更新部分网页内容的网页开发技术

Ajax在浏览器是通过XMLHttpRequest对象来实现数据传输的。

、AJAX 的工作流程
事件触发
比如，用户点击按钮或页面加载时，js 脚本会触发 AJAX 请求。
创建 XMLHttpRequest 对象
这是浏览器提供的 API，用于和服务器交换数据。
配置请求参数
设置请求方法（GET/POST/PUT/DELETE）、目标 URL、是否异步等。
发送请求
通过 send() 方法向服务器发送请求，并在此期间页面不会被阻塞。
服务器处理并响应
服务器收到请求后，进行逻辑处理，将响应数据返回前端（可以是JSON、XML、HTML、纯文本等）。
前端接收并处理响应
利用事件监听（如 readyState/onreadystatechange 或 onload），当数据返回时，处理响应并局部更新页面内容。
三、常见使用方式代码例子
1. 原生 XMLHttpRequest 示例

var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onreadystatechange = function() {
    if(xhr.readyState === 4 && xhr.status === 200) {
        var response = JSON.parse(xhr.responseText);
        // 局部操作DOM，刷新内容
        document.getElementById('result').innerText = response.msg;
    }
};
xhr.send();

javascript


2. jQuery 简化AJAX

$.ajax({
    url: 'https://api.example.com/data',
    method: 'GET',
    dataType: 'json',
    success: function(data) {
        $('#result').text(data.msg);
    }
});

javascript


3. 现代 fetch API 示例（推荐用于新项目）

fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => {
        document.getElementById('result').innerText = data.msg;
    });

javascript


四、AJAX 的优点
提升用户体验：无需刷新整个页面，响应更快、更流畅；
减少带宽消耗：只请求/响应页面部分数据；
更动态的交互能力：实现异步数据加载，条件查询，实时校验等高级交互。
五、注意事项与常见问题
同源策略与跨域问题
默认情况下，AJAX 受同源策略限制，需服务器端支持 CORS（跨域资源共享）或使用 JSONP 进行跨域访问。
浏览器兼容性
现代浏览器皆完美支持 XMLHttpRequest/fetch，但老浏览器须关注兼容性。
请求/响应时序
注意异步下顺序，合理处理 Promise/回调，避免竞态与回调地狱。
安全问题
防止CSRF/注入攻击，验证数据有效性和来源。
六、典型应用场景
搜索联想与实时查询（如百度、谷歌搜索框下拉）
表单验证（实时校验用户名、邮箱等）
聊天、消息通知、新闻流更新
数据驱动的单页面应用（SPA）
七、AJAX 与现代前端的关系
现代的 Vue、React 或 Angular 等框架通常用 fetch 或 axios 等库封装 AJAX 请求，管理 API 与组件状态解耦。
AJAX 概念无处不在，但实现方式趋于统一、简便和可维护。

XMLHttpRequest对象进行HTTP请求前必须通过open初始化，open接受五个参数，分别为请求方法、请求链接、异步标识、账号和密码用以服务端验证。

open(Method, URL, Asynchronous, UserName, Password);
在成功初始化请求之后，XMLHttpRequest对象的setRequestHeader方法可以用来设置请求头。

setRequestHeader(key,value);
调用open()方法后，就可以通过调用send()方法按照open方法设定的参数将请求进行发送。

send(data);
当open方法设定发送的方式为异步请求时，onreadystatechange事件监听器将自动在XMLHttpRequest对象的readyState属性改变时被触发。

switch(readyState){
    case 1: break; // 当`open`方法被成功调用 `readyState`为`1`
    case 2: break; // 当`send`方法被调用 `readyState`属性被置为`2`
    case 3: break; // `HTTP`响应内容开始加载 `readyState`属性被置为`3`
    case 4: break; // `HTTP`响应内容结束加载 `readyState`属性被置为`4`
}
如果XMLHttpRequest对象的readyState属性还没有变成4，abort可以终止请求。这个方法可以确保异步请求中的回调不被执行。

abort();
实现
由于浏览器的同源策略(协议、域名、端口号任一不同都算为跨域请求)，于是此代码需要打开百度的首页，在开发者工具的Console直接执行，在Network查看效果。

function ajax(url,method="GET", data=null, async=true) {
  // 声明`XMLHttpRequest` // 在`IE5`和`IE6`中需要使用`ActiveX`对象
  let XHR = XMLHttpRequest;
  // 创建`XMLHttqRequest`对象
  XHR = new XMLHttpRequest();
  // 设置请求状态改变时执行的函数
  XHR.onreadystatechange = function() {
      // `XHR.responseText`为响应体
      if (XHR.readyState === 4) console.log(`响应状态:${XHR.status}`, "FINISH");
  }
  // 初始化请求参数
  XHR.open(method,url, async);
  // 发起请求
  XHR.send(data);
}

ajax("https://www.baidu.com");
ajax("https://www.baidu.com", "POST", "A=1&B=2");
---





### **Vue 中的 `v-if` 和 `v-for` 指令详解**

`v-if` 和 `v-for` 是 Vue 中两个非常重要的指令，用于控制 DOM 的渲染和列表的渲染。它们在 Vue 的模板语法中非常常用，下面我们详细介绍它们的功能、用法、注意事项以及最佳实践。

---

## **1. `v-if` 指令**

### **1.1 定义**
`v-if` 是一个条件渲染指令，用于根据表达式的值来决定是否渲染某个 DOM 元素。

### **1.2 基础语法**
```html
<div v-if="condition">内容</div>
```
- `condition` 是一个布尔值，当为 `true` 时，渲染该元素；为 `false` 时，移除该元素。

### **1.3 使用示例**

#### **基本用法**
```html
<div id="app">
  <p v-if="isVisible">Hello, Vue!</p>
</div>

<script>
  new Vue({
    el: '#app',
    data: {
      isVisible: true
    }
  });
</script>
```
- 当 `isVisible` 为 `true` 时，页面会显示 `Hello, Vue!`。
- 当 `isVisible` 为 `false` 时，`<p>` 标签会被移除。

#### **`v-else` 和 `v-else-if`**
- `v-else`：在 `v-if` 为 `false` 时渲染。
- `v-else-if`：为 `v-if` 的条件分支。

```html
<div id="app">
  <p v-if="type === 'success'">成功</p>
  <p v-else-if="type === 'warning'">警告</p>
  <p v-else>错误</p>
</div>

<script>
  new Vue({
    el: '#app',
    data: {
      type: 'warning'
    }
  });
</script>
```
- 如果 `type` 为 `'success'`，渲染第一个 `<p>`。
- 如果 `type` 为 `'warning'`，渲染第二个 `<p>`。
- 如果 `type` 既不是 `'success'` 也不是 `'warning'`，渲染第三个 `<p>`。

---

### **1.4 注意事项**
1. **性能问题**：
   - `v-if` 的元素在条件为 `false` 时会被完全移除，包括事件监听器和子组件。
   - 如果需要频繁切换，可以考虑使用 `v-show`（仅隐藏元素，不移除）。

2. **`v-if` 和 `v-for` 的优先级**：
   - 当 `v-if` 和 `v-for` 同时存在时，`v-for` 的优先级更高。
   - 如果需要条件渲染列表中的某些项，可以将 `v-if` 放在子元素上：
     ```html
     <ul>
       <li v-for="item in items" v-if="item.visible">{{ item.name }}</li>
     </ul>
     ```

3. **动态组件与 `v-if`**：
   - `v-if` 可以与动态组件结合使用，按需加载组件。
     ```html
     <component v-if="isLoggedIn" :is="'UserProfile'"></component>
     ```

---

## **2. `v-for` 指令**

### **2.1 定义**
`v-for` 是一个循环渲染指令，用于根据数组或对象渲染列表。

### **2.2 基础语法**
```html
<div v-for="item in items">{{ item }}</div>
```
- `item in items`：`items` 是一个数组，`item` 是数组中的每一项。

### **2.3 使用示例**

#### **渲染数组**
```html
<div id="app">
  <ul>
    <li v-for="fruit in fruits">{{ fruit }}</li>
  </ul>
</div>

<script>
  new Vue({
    el: '#app',
    data: {
      fruits: ['Apple', 'Banana', 'Cherry']
    }
  });
</script>
```
- 输出：
  ```html
  <ul>
    <li>Apple</li>
    <li>Banana</li>
    <li>Cherry</li>
  </ul>
  ```

#### **渲染数组的索引**
```html
<ul>
  <li v-for="(fruit, index) in fruits">{{ index }}: {{ fruit }}</li>
</ul>
```
- 输出：
  ```html
  <ul>
    <li>0: Apple</li>
    <li>1: Banana</li>
    <li>2: Cherry</li>
  </ul>
  ```

#### **渲染对象**
```html
<div id="app">
  <ul>
    <li v-for="(value, key) in user">{{ key }}: {{ value }}</li>
  </ul>
</div>

<script>
  new Vue({
    el: '#app',
    data: {
      user: {
        name: 'John',
        age: 30,
        location: 'New York'
      }
    }
  });
</script>
```
- 输出：
  ```html
  <ul>
    <li>name: John</li>
    <li>age: 30</li>
    <li>location: New York</li>
  </ul>
  ```

---

### **2.4 `v-for` 与组件**
`v-for` 可以用于渲染组件，并支持传递 `props`。

#### **示例**
```html
<div id="app">
  <user-card v-for="user in users" :key="user.id" :user="user"></user-card>
</div>

<script>
  Vue.component('user-card', {
    props: ['user'],
    template: '<div>{{ user.name }} ({{ user.age }})</div>'
  });

  new Vue({
    el: '#app',
    data: {
      users: [
        { id: 1, name: 'Alice', age: 25 },
        { id: 2, name: 'Bob', age: 30 }
      ]
    }
  });
</script>
```
- 输出：
  ```html
  <div>Alice (25)</div>
  <div>Bob (30)</div>
  ```

---

### **2.5 注意事项**
1. **`key` 属性**：
   - 使用 `v-for` 渲染列表时，建议为每个元素添加唯一的 `key`，以提高性能并避免渲染问题。
     ```html
     <li v-for="item in items" :key="item.id">{{ item.name }}</li>
     ```

2. **`v-for` 和 `v-if` 的优先级**：
   - `v-for` 的优先级高于 `v-if`。
   - 如果需要条件渲染列表中的某些项，请将 `v-if` 放在 `v-for` 的子元素上。

3. **避免嵌套过深**：
   - 嵌套的 `v-for` 会导致代码复杂且性能下降，尽量简化数据结构。

4. **数组更新检测**：
   - Vue 能够检测数组的变动（如 `push`、`pop` 等），但无法检测直接修改索引或长度：
     ```javascript
     this.items[0] = 'New Value'; // Vue 无法检测
     this.items.splice(0, 1, 'New Value'); // 推荐方式
     ```

---

## **3. `v-if` 与 `v-for` 的结合**

### **3.1 示例**
在列表渲染中使用条件渲染：
```html
<ul>
  <li v-for="item in items" v-if="item.visible">{{ item.name }}</li>
</ul>
```
- 每次循环时，会检查 `item.visible` 的值，决定是否渲染。

### **3.2 注意事项**
- 如果同时使用 `v-if` 和 `v-for`，最好将 `v-if` 放在子元素上，而不是与 `v-for` 同级：
  ```html
  <ul>
    <li v-for="item in items">
      <span v-if="item.visible">{{ item.name }}</span>
    </li>
  </ul>
  ```

---

## **总结**

| 指令   | 功能                                                                 | 注意事项                                                                 |
|--------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `v-if` | 条件渲染，根据表达式的值决定是否渲染元素。                           | 性能开销较大，适合用于不频繁切换的场景；优先级低于 `v-for`。               |
| `v-for`| 列表渲染，根据数组或对象生成多个 DOM 元素。                          | 需要使用 `key` 提高性能；优先级高于 `v-if`；避免嵌套过深。                 |

通过合理使用 `v-if` 和 `v-for`，可以轻松实现动态渲染和列表渲染的功能，同时提升代码的可读性和性能。
---



### **React 中的条件渲染和列表渲染详解**

在 React 中，条件渲染和列表渲染是构建动态用户界面的核心功能。React 使用 JavaScript 表达式和 JSX 语法来实现这些功能。下面我们详细介绍 React 中的条件渲染和列表渲染的语法、使用方法、注意事项以及最佳实践。

---

## **1. 条件渲染**

### **1.1 定义**
条件渲染是根据某个条件表达式的结果，动态地决定是否渲染某些组件或元素。在 React 中，条件渲染通常通过以下方式实现：
- 使用 `if-else` 语句
- 使用三元运算符
- 使用逻辑与 (`&&`) 运算符
- 使用函数返回 JSX

---

### **1.2 实现方式**

#### **1.2.1 使用 `if-else` 语句**
通过 `if-else` 语句控制渲染不同的内容。

```jsx
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;

  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    return <h1>Please sign in.</h1>;
  }
}

// 使用组件
<Greeting isLoggedIn={true} />
```

---

#### **1.2.2 使用三元运算符**
三元运算符是一种简洁的条件渲染方式。

```jsx
function Greeting(props) {
  return (
    <h1>
      {props.isLoggedIn ? 'Welcome back!' : 'Please sign in.'}
    </h1>
  );
}

// 使用组件
<Greeting isLoggedIn={false} />
```

---

#### **1.2.3 使用逻辑与 (`&&`) 运算符**
适合在条件为 `true` 时渲染内容，而条件为 `false` 时不渲染任何内容。

```jsx
function Notification(props) {
  return (
    <div>
      {props.hasNewMessages && <p>You have new messages!</p>}
    </div>
  );
}

// 使用组件
<Notification hasNewMessages={true} />
```

---

#### **1.2.4 使用函数返回 JSX**
可以将条件逻辑封装在函数中，返回不同的 JSX。

```jsx
function renderMessage(isLoggedIn) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    return <h1>Please sign in.</h1>;
  }
}

function App() {
  const isLoggedIn = true;
  return <div>{renderMessage(isLoggedIn)}</div>;
}
```

---

### **1.3 条件渲染的注意事项**
1. **避免不必要的复杂性**：
   - 如果条件逻辑过于复杂，建议拆分为多个小的函数或组件。
2. **条件表达式的返回值**：
   - 条件表达式必须返回合法的 JSX 或 `null`，不能返回 `undefined`。
3. **条件渲染的性能**：
   - 尽量避免多层嵌套的条件语句，保持代码的清晰性。

---

## **2. 列表渲染**

### **2.1 定义**
列表渲染是根据数组中的数据，动态生成一组组件或元素。React 使用 JavaScript 的 `map()` 方法来实现列表渲染。

---

### **2.2 基础语法**
```jsx
const items = ['Apple', 'Banana', 'Cherry'];

function ItemList() {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

- `items.map()`：遍历数组，为每个元素生成一个 `<li>`。
- `key` 属性：React 要求列表中的每个子元素必须有一个唯一的 `key`，以便高效更新 DOM。

---

### **2.3 使用示例**

#### **2.3.1 渲染数组**
```jsx
const fruits = ['Apple', 'Banana', 'Cherry'];

function FruitList() {
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}
```

---

#### **2.3.2 渲染对象数组**
```jsx
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];

function UserList() {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name}
        </li>
      ))}
    </ul>
  );
}
```

---

#### **2.3.3 渲染组件**
```jsx
const users = [
  { id: 1, name: 'Alice', age: 25 },
  { id: 2, name: 'Bob', age: 30 }
];

function UserCard({ user }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>Age: {user.age}</p>
    </div>
  );
}

function UserList() {
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

---

### **2.4 列表渲染的注意事项**

1. **`key` 属性**：
   - `key` 是 React 用于识别列表中每个元素的唯一标识。
   - `key` 应该是稳定且唯一的（如 ID），不能使用索引作为 `key`，除非列表不会动态变化。

2. **避免直接修改状态中的数组**：
   - React 的状态是不可变的，修改数组时应返回一个新的数组。
   ```jsx
   const [items, setItems] = useState(['Apple', 'Banana']);
   setItems([...items, 'Cherry']);
   ```

3. **嵌套列表渲染**：
   - 如果列表中包含嵌套数据，可以使用递归渲染。

---

## **3. 条件渲染与列表渲染结合**

在实际开发中，条件渲染和列表渲染经常结合使用。例如，渲染一个列表时，可以根据条件决定是否渲染某些项。

```jsx
const items = [
  { id: 1, name: 'Apple', visible: true },
  { id: 2, name: 'Banana', visible: false },
  { id: 3, name: 'Cherry', visible: true }
];

function ItemList() {
  return (
    <ul>
      {items.map(item => (
        item.visible && <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

---

## **4. 总结**

### **条件渲染**

| 方法                  | 说明                           | 示例                                  |
|-----------------------|--------------------------------|---------------------------------------|
| `if-else`             | 使用传统的 `if-else` 语句      | `if (condition) { ... } else { ... }` |
| 三元运算符            | 简洁的条件渲染方式             | `condition ? <A /> : <B />`           |
| 逻辑与 (`&&`) 运算符  | 条件为真时渲染内容             | `condition && <A />`                  |
| 函数返回 JSX          | 将条件逻辑封装在函数中         | `return condition ? <A /> : <B />`    |

---

### **列表渲染**

| 方法                  | 说明                           | 示例                                  |
|-----------------------|--------------------------------|---------------------------------------|
| 数组的 `map()` 方法   | 遍历数组生成列表项             | `items.map(item => <li>{item}</li>)` |
| 渲染对象数组          | 渲染对象数组时需要 `key` 属性  | `<li key={obj.id}>{obj.name}</li>`    |
| 嵌套列表渲染          | 递归渲染多层嵌套数据           | `items.map(renderNestedItems)`        |

通过熟练使用条件渲染和列表渲染，React 开发者可以轻松构建动态且高效的用户界面。
---



### **React 中的 Hooks 详解**

React 的 Hooks 是自 React 16.8 引入的一种新特性，用于在函数组件中管理状态和副作用。它们使函数组件能够完成以前只能通过类组件实现的功能，例如状态管理、生命周期方法等。

---

## **1. 什么是 Hooks？**

Hooks 是一类特殊的函数，它们以 `use` 开头，并允许你在函数组件中“钩入” React 的功能，比如状态和生命周期。

### **1.1 为什么使用 Hooks？**
- **简化代码**：通过 Hooks，可以在函数组件中管理状态和副作用，减少了类组件的复杂性。
- **逻辑复用**：自定义 Hook 可以让状态逻辑在组件之间复用。
- **减少嵌套**：避免高阶组件（HOC）和渲染属性（Render Props）带来的嵌套问题。
- **更贴近函数式编程**：函数组件更轻量、更易于测试。

---

## **2. 常用的内置 Hooks**

### **2.1 `useState`**
用于在函数组件中添加状态。

#### **语法**
```javascript
const [state, setState] = useState(initialState);
```

#### **示例**
```javascript
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

---

### **2.2 `useEffect`**
用于处理副作用（例如数据获取、订阅或手动操作 DOM）。

#### **语法**
```javascript
useEffect(() => {
  // 副作用逻辑
  return () => {
    // 清理逻辑（可选）
  };
}, [dependencies]); // 依赖项数组
```

#### **示例**
```javascript
import React, { useState, useEffect } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount((prevCount) => prevCount + 1);
    }, 1000);

    return () => clearInterval(interval); // 清理定时器
  }, []); // 空依赖数组，表示只在组件挂载和卸载时执行

  return <p>Timer: {count}s</p>;
}
```

---

### **2.3 `useContext`**
用于在组件中访问上下文（`Context`）。

#### **语法**
```javascript
const value = useContext(MyContext);
```

#### **示例**
```javascript
import React, { useContext } from 'react';

const ThemeContext = React.createContext('light');

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Themed Button</button>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

---

### **2.4 `useReducer`**
用于在函数组件中管理复杂状态逻辑（类似于 Redux 的 reducer）。

#### **语法**
```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

#### **示例**
```javascript
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}
```

---

### **2.5 其他内置 Hooks**
- **`useRef`**：获取或存储一个可变的引用。
- **`useMemo`**：优化性能，避免不必要的计算。
- **`useCallback`**：优化性能，避免不必要的函数重新创建。
- **`useLayoutEffect`**：与 `useEffect` 类似，但在 DOM 更新后同步执行。
- **`useImperativeHandle`**：配合 `forwardRef` 使用，暴露自定义的实例方法。

---

## **3. 自定义 Hook**

### **3.1 什么是自定义 Hook？**
自定义 Hook 是一个以 `use` 开头的普通函数，用于封装组件间可复用的逻辑。它们可以调用其他 Hook。

### **3.2 编写自定义 Hook**

#### **示例 1：创建一个 `useCounter` Hook**
```javascript
import { useState } from 'react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
}

// 使用自定义 Hook
function Counter() {
  const { count, increment, decrement, reset } = useCounter(10);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

---

#### **示例 2：创建一个 `useFetch` Hook**
```javascript
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Failed to fetch');
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// 使用自定义 Hook
function App() {
  const { data, loading, error } = useFetch('https://jsonplaceholder.typicode.com/posts');

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

---

### **3.3 编写自定义 Hook 的注意事项**
1. **以 `use` 开头**：
   - React 通过 `use` 前缀判断是否是 Hook。
2. **遵循 Hook 的规则**：
   - **只能在函数组件或自定义 Hook 中调用 Hook**。
   - **只能在顶层调用 Hook**（不能在循环、条件或嵌套函数中调用）。
3. **封装逻辑**：
   - 自定义 Hook 应该只关注逻辑复用，不负责 UI 渲染。

---

## **4. 总结**

### **内置 Hooks**
| Hook             | 作用                              |
|------------------|-----------------------------------|
| `useState`       | 添加状态                         |
| `useEffect`      | 处理副作用                       |
| `useContext`     | 使用上下文                       |
| `useReducer`     | 管理复杂状态逻辑                 |
| `useRef`         | 获取或存储可变的引用             |
| `useMemo`        | 缓存计算结果                     |
| `useCallback`    | 缓存函数                         |
| `useLayoutEffect`| 同步处理 DOM 更新后的副作用     |

### **自定义 Hook**
- 自定义 Hook 是封装逻辑复用的最佳方式。
- 它让代码更简洁、可读性更强，且方便在多个组件中共享逻辑。

通过灵活使用 React 的内置 Hooks 和自定义 Hook，可以大幅提升代码的可维护性和开发效率！