# 🧰 前端工程化
---
## 前端工程化（框架）

将前端开发过程中一系列`流程`和`工具`进行`规范化`，并使用相关技术实现`自动化` | 提高`开发效率` 提高`代码质量`和`可维护性`

1. `项目初始化` 快速建立可维护项目的基础结构
    - 包管理工具：`npm` `yarn` `pnpm`
    - 脚手架工具：`create-react-app` `vue-cli`
2. `模块化/组件化开发` 结构清晰、可复用、易维护
    - 模块化规范：`CommonJS`(Node.js中使用) `ES Module`
    - 组件化框架：`React` `Vue` `Svelte` `Solid.js`
3. `构建与打包` 将代码编译、优化成可在生产环境运行的资源
    - 构建工具：`Webpack` `Vite` `Rollup` `Esbuild`
4. `代码规范与质量` 保证团队协作代码风格统一、减少潜在错误
    - 代码规范检查：`ESLint` `Prettier` `Stylelint`
    - 类型检查：`TypeScript` `Flow`
    - 代码提交规范：`Git Hooks` `Commit message`
---
## Node.js 在前端工程化中的作用
`1 运行环境` `2 工具支撑` `3 开发体验提升`
1. 工具链的运行环境
    - 以前浏览器之外，`JavaScript` 是没法直接运行的，`Node.js` 让我们可以在`本地直接执行 JavaScript`，这意味着：
    - 前端构建工具（Webpack/Vite/Rollup）都能在本地跑
    - 脚手架（如 `create-react-app`、`vue-cli`）能直接生成项目
2. 模块化与包管理 工具链的依赖环境
    - 包管理器（npm / yarn / pnpm）依赖 Node.js、
    - 构建工具（Webpack、Rollup、Vite）运行在 Node.js 环境
    - Lint / 格式化工具（ESLint、Prettier）也是 Node.js 脚本
    - 允许前端代码通过`require`或`import`引入第三方库
3. 本地开发服务器与代理
    - Node.js 自带`网络模块（http）`，可以很方便地启动本地开发服务：
    - 热更新（HMR）依赖 Node.js 服务器来推送变更
    - API Mock（接口模拟）可直接用 Node.js 写本地接口
    - 前后端同构渲染（SSR）直接用 Node.js 处理 HTML 模板
    - 解决跨域问题时，常用`Node.js`中间件（如 `http-proxy-middleware`）做请求转发。
4. 自动化脚本与工具开发
    - 批量构建多个项目
    - CI/CD 脚本（部署、构建、运行测试）
    - 文件监听（用 `chokidar` 等库）
    - 脚本工具化（用 `commander` 写 CLI 工具）
    - 开发自定义 CLI 工具（如生成模板代码、批量处理文件）
5. 跨平台开发支持
    - Node.js 的跨平台能力（Windows / macOS / Linux 都能跑）
---
## Webpack 和 Vite
`Webpack` 和 `Vite` 是两种广泛使用的构建工具
- 【 入口文件 】
  - **`Webpack`** 默认入口是 `src/index.js`，但可通过 `entry` 配置修改
  - **`Vite`** 没有强制的入口，直接基于 `index.html`，通过 `<script type="module">` 作为入口（更贴近浏览器原生运行）
- 【 开发模式的差异 】
  - **`Webpack`** 开发环境中先打包再启动开发服务器 【 1.遍历依赖 | 2.全量打包 | 3.启动服务器 】增加启动时间和构建时间
  - **`Vite`** 直接启动 再按需编译依赖文件【 1.启动服务器 | 2.按需加载 | 3.动态加载 】（ 打开浏览器F12 检查源码 `Sources` ）
  - 现代浏览器本身就支持 `ES Modules` 会主动发起请求去获取所需文件 `Vite` 充分利用了这一点 将开发环境下的模块文件直接作为浏览器要执行的文件 而不是像 `Webpack` 那样先打包 再交给浏览器执行
- 【 底层语言 】
  - `Webpack` 基于 `Node.js` 构建
  - `Vite` 基于 `esbuild` 进行预构建
- 【 热更新的处理 】
  - `Webpack` ｜ 当一个模块或其依赖的模块内容改变时 需要重新编译这些模块
  - `Vite` ｜ 当某个模块内容改变时 只需要让浏览器重新请求这个模块即可 大大减少热更新时间
---
## ES Modules
`JavaScript` 在 `ES6（2015）`中引入的官方模块化标准 | 在 ES6 之前，JavaScript 并没有统一的模块系统：
- `浏览器`：只能用 `<script>` 标签引入，所有 `JS` 都是全局变量，很容易冲突
- `Node.js`：早期用 `CommonJS (CJS)`（`require` / `module.exports`），但这不是浏览器原生支持的
- 【特征】
  - 静态导入导出 ｜ 使用 `import` / `export`，在代码运行前就能确定依赖关系
  - 有利于编译器优化（比如 `Tree Shaking`）
  - 按需导入导出 | 只引入用到的部分，避免把整个文件都加载
  - 严格模式 | ESM 默认就是严格模式（`'use strict'` 不需要写）
  - 异步加载 | 浏览器原生支持 `<script type="module">`，加载时不会阻塞 `HTML` 解析
  - 浏览器原生支持 | 现代浏览器直接支持，不需要打包工具
- `ES Modules` VS `CommonJS`

| 特性 | ESM | CommonJS (CJS) |
| --- | --- | --- |
| 语法 | `import` / `export` | `require` / `module.exports` |
| 加载 | 静态编译时确定依赖 | 运行时动态加载 |
| 是否异步 | 异步（更适合浏览器） | 同步（更适合 Node.js）|
| 优化 | 支持 Tree Shaking | 不支持 |
| 应用 | 浏览器 + Node.js | 主要在 Node.js（旧项目多）|

- `Tree Shaking` | 就是打包时移除没有用到的代码
- `ES Modules`是异步的｜加载特点：**(1)** 浏览器遇到 `<script type="module">` 会异步下载和解析依赖，不会阻塞 `HTML` 渲染。**(2)** `import` 本身是静态声明，但浏览器执行时会异步请求依赖文件（走网络）
- `CommonJS 特点`是同步的｜加载特点：**(1)** 用 `require` 引入模块：执行到这一行时，必须立刻去磁盘（或缓存）加载并执行 math.js，然后才往下走。所以 `require` 是阻塞式的同步操作。**(2)** CommonJS 设计场景是 Node.js 服务器，本地磁盘 IO 很快，不需要异步。**(3)** 如果放在浏览器里，require 就很慢（要阻塞等待整个模块加载），所以 CJS 不适合浏览器端直接使用。