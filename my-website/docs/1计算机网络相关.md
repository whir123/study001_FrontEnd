---
id: 1
title: 计算机网络相关
---

# 💻 计算机网络相关
---
## HTTP 和 HTTPS
客户端（浏览器等）和服务器传输数据的协议（应用层协议）
* `HTTP（HyperText Transfer Protocol）`：明文传输 无加密 基于 TCP/IP 默认端口 80 
* `HTTPS （HyperText Transfer Protocol Secure）`：+SSL/TLS 协议 需从权威机构申请SSL证书 默认443端口
* `SSL （Secure Sockets Layer 安全套接字层）`已被 `TLS（Transport Layer Security 传输层安全协议）`取代
* `TLS（Transport Layer Security）是 SSL` 的标准化版本，由 IETF（互联网工程任务组）在 1999 年推出，基于 SSL 3.0 改进，并命名为 TLS 1.0（避免法律问题）：`机密性：加密传输` `完整性：防篡改` `身份验证`
* HTTPS 封装过程：生成原始数据 SSL/TLS 加密 并添加数字验证 ｜ 传输层 TCP 将加密后的数据分段 并添加端口号 ｜ 网络层 IP 添加源/目标 ip 地址 通过路由器传输
* `TCP（Transmission Control Protocol 传输控制协议）`传输层协议，确保数据可靠、有序地传输（HTTP/HTTPS 均依赖 TCP）
`IP（Internet Protocol 网际协议） 网络层协议`，负责数据包的路由和寻址（如 IP 地址）
---
## HTTP/1.1 和 HTTP/2
`超文本传输协议` 万维网的基础通信协议
- `0.9` 第一个协议版本 简单的网页传输 仅支持 GET 请求 明文 单向
- `1.0` 开始支持复杂的应用场景 引入 `HTTP头部` 增加`状态码` 每次请求都重新建立 `TCP连接` 传输完成后关闭
- `1.1` 目前最广泛
  - 持久连接 | `一个TCP连接`上 发送`多个HTTP请求和响应` 避免每次请求重新连接
  - 管道化 | 客户端发送请求后 不必等待响应 可以继续发下一个请求
  - 分块传输编码 | 适合内容动态生成
  - 虚拟主机支持 | 通过`host头部`支持虚拟主机 多个域名共享一个 IP 地址
- 【缺点】队头阻塞 | 虽支持持久连接：但`同一时间`只能处理`一个请求` 即使管道化：响应顺序限制 —> 阻塞
- 【缺点】多连接占用资源 ｜ 为提升性能`浏览器同一域名`打开`多个TCP连接`（通常是6个）
- `2` 基于 SPDY 协议开发设计
  - 二进制格式代替1.1的纯文本格式
  - 一个 TCP 连接同时发送多个请求和响应 且互不干扰
  - 一个请求和响应 看作一个数据流 流中数据分割成多个帧（交错发送 根据流标识重新组装）
  - HPACK 算法对首部信息压缩（`Cookie` `User-Agent` 等 1.1是重复发送 2是增量更新）
  - 支持服务器主动向客户端推送资源 即使客户端未请求 （减少延迟 提高加载速度）
  - 不强制加密 但主流浏览器只支持通过`https`使用`http/2`
---
## HTTP 请求方法
HTTP Request Methods ：`客户端 => 服务器` 发送请求时操作指令
* `GET` 请求获取制定资源 数据通过 URL 传递
* `POST` 向服务器提交数据 数据通过请求体 Body 传输 支持加密与大数据
* `DELETE` 删除指定资源
* `PUT` 更新或替换资源（全量更新）提供完整资源数据 如不存在 可能创建
* `PATCH` 对资源部分更新（增量更新） 仅发送需要修改的字段
* `...`
  * 幂等性: 重要接口（如支付）应设计为幂等（如用 PUT 替代 
  * 安全性: GET 请求参数会暴露在 URL 中，敏感数据需用 POST+HTTPS
  * 语义化: 遵循 RESTful 规范，避免滥用 POST 替代其他方法。
---
## HTTP 状态码
第一位代表响应类别：
* `1xx` 信息响应 信息已被接收 继续处理		
  * 100 继续 ｜ 101 切换协议
* `2xx` 成功响应 请求已处理
  * 200 OK 成功 ｜ 201 Created 已创建 ｜ 204 No Content 无内容 如 DELETE 成功
* `3xx` 重定向响应 请求需要进一步操作		
  * 301 永久重定向 浏览器会缓存 ｜ 302 临时重定向 资源临时移至新 URL
* `4xx` 客户端错误 请求有误 服务器无法处理
  * 400 错误 请求语法错误等 ｜ 401 未授权 如需身份认证需登录等 ｜ 403 禁止访问 权限不足等 ｜404 未找到
* `5xx` 服务器错误 服务器处理请求出错		
  * 500 服务器内部错误 ｜ 503 服务不可用 服务器维护等
---
## WebSocket
`全双工通信协议` 允许客户端与服务器建立持久连接 双向实时数据交换 一次握手长期保持连接（除非主动关闭）｜本质上是运行在`应用层`
* 底层传输依赖 TCP`(传输层)` 、是 HTTP 的补充
* HTTP: 短连接 单向 ｜WebSocket: 长连接 双向
* 1 握手阶段：通过 http 协议发起 客户端发起升级请求 服务器同意升级后返回 101 `Sec-WebSocket-Key（客）`和 `Sec-WebSocket-Accept（服）`用于验证握手
* 2 数据传输阶段：握手完成 数据以`帧`的形式传输
  * 文本帧（UTF-8） ｜ 二进制帧（图片/音频等） ｜ 控制帧（管理连接）
* 局限性：连接保持开销 占用服务器资源 ｜ 基于 HTTP/1.1 无法复用 HTTP/2.2 多路复用
* 替代方案：`SSE（Server-Sent-Events）` `长轮询（Long Poilling）`
---
## SSE 和 Long Poilling
* SSE | Server-Sent-Events｜`应用层协议`
  * 基于 HTTP 单向通道：服务端 => 客户端 实时推送数据技术 数据格式简单（纯文本或 JSON）:
    * 客户端通过 HTTP 请求向服务器订阅
    * 服务器保持连接不断开，持续发送事件数据
    * 数据格式是纯文本，通常是 UTF-8 编码的 text/event-stream
    * 天生支持自动重连和事件 ID（浏览器原生支持）
  * 工作流程:
    - 客户端用 EventSource API 发起 GET 请求
    - 服务器设置 Content-Type: text/event-stream，然后一直写数据
    - 浏览器解析每条 event: xxx\ndata: yyy\n\n 格式的消息，并触发监听器
* Long Poilling | 长轮询｜`应用层协议`
  * 客户端发起一个 HTTP 请求，服务器不立即响应，而是等到有数据时才返回 | 模拟双向实时 通过 HTTP 请求“挂起”实现低延迟 | 工作流程：
    * 客户端发送请求
    * 服务器保持请求不返回，直到有新数据才返回
    * 客户端立即发起下一次请求
    * 重复以上
---
## 三次握手与四次挥手
`TCP协议`：传输层（Transport Layer）为应用层（HTTP、FTP、SMTP 等）提供`可靠的`、`面向连接的`、`端到端的`字节流传输服务 ｜ 三次挥手：确立连接 四次挥手：终止连接 ｜ 传输过程中使用`确认机制`、`重传机制`、`流量控制`和`拥塞控制`来保证数据的可靠性

【 传输层：`段 Segment`｜应用层：`消息 Message`｜TCP 把应用层交下来的数据看作没有边界的`字节序列 Byte Stream`｜UDP 则面向`报文 Message Oriented` 】

双方就各自的初始序列号（ISN）达成共识，并确认“我能收发、你也能收发” `SYN`:同步序列号 `ACK`:确认
- `TCP服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了 `LISTEN 监听状态`
- `第一次握手` `TCP客户进程`也是先创建`传输控制块TCB`，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 `SYN-SENT 同步已发送状态`
- `第二次握手` TCP服务器收到请求报文后，如果同意连接，则会向客户端发出`确认报文`。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 `SYN-RCVD 同步收到状态`
- `第三次握手` TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入`ESTABLISHED已建立连接状态` 触发三次握手
  - 为什么要进行第三次握手？：主要原因：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误
  - 第一次握手： 客户端向服务器端发送报文 证明客户端的发送能力正常
  - 第二次握手：服务器端接收到报文并向客户端发送报文 证明服务器端的接收能力、发送能力正常
  - 第三次握手：客户端向服务器发送报文 证明客户端的接收能力正常

TCP 是全双工的，两个方向各自独立关闭，需要各自 `FIN`/`ACK` 一对，因此通常是四次: `FIN:发送方不再发送数据（但仍可收）` `ACK:确认`
- 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于`ESTABLISHED状态`，然后客户端主动关闭，服务器被动关闭
- `第一次挥手` 客户端发出`连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（=前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入`FIN-WAIT-1 终止等待1`状态
- `第二次挥手` 服务器端接收到`连接释放报文`后，发出`确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了`CLOSE-WAIT 关闭等待状态`
- `第三次挥手` 客户端接收到服务器端的确认请求后，客户端就会进入`FIN-WAIT-2 终止等待2`状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送`连接释放报文`，服务器就进入了`LAST-ACK 最后确认`状态，等待客户端的确认
- `第四次挥手` 客户端收到服务器的`连接释放报文`后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了`TIME-WAIT 时间等待状态`，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当`客户端撤销相应的TCB`后，客户端才会进入`CLOSED关闭状态`，服务器端接收到`确认报文`后，会立即进入`CLOSED关闭状态`，到这里TCP连接就断开了，四次挥手完成
  - 为什么客户端要等待`2MSL`？:主要原因是为了保证客户端发送那个的`第一个ACK报文能到到服务器`，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文
---
## Cookie Session Token｜HTTP协议层的状态管理与认证机制
Web 应用中，用户的`认证和鉴权`是非常重要的一环；`HTTP` 是一个`无状态的协议` => 一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（`同一个 IP 不代表同一个用户`）=> 无法确定本次请求和上一次请求是不是同一个人发送的

`Http会话保持`是Web开发中常用的技术，用来跟踪用户的整个会话。以前Web网站早期常用的会话保持技术是`Session和Cookie机制`，现在的Web网站和移动端可以通用`Token机制`
1. 基于 `Session` 和 `Cookie` 的会话管理机制
   - **`Cookie`** : 浏览器保存的一小段键值对，随请求自动携带到相同域名
   - 客户端首次访问：验证账户密码
   - 服务端验证后：响应+设置Cookie ｜ 一小段键值对
   - 浏览器保存Cookie到本地
   - 客户端再次访问时: 自动携带Cookie
   - 弊端：安全风险 可篡改（服务器设置 `HttpOnly` 的 Cookie 不能被 JS 改）｜存储限制 4kb左右｜数量限制 每个域名几十个
   - **`Session`** : 将用户状态信息存储在服务器里 再发一个Session ID到客户端浏览器
   - 客户端首次访问：验证账户密码 无`Session`
   - 服务端验证后：生成新Session存储 响应+设置Cookie（SessionID=S_123）
   - 客户端下次请求 携带Cookie
   - 弊端：占用大量的服务器资源｜创建 Session 的服务器可能不是验证 Session 的服务器｜Cookie跨域限制｜移动端App（大部份）没有Cookie
2. 基于 `Token` 的会话管理机制
   - 客户端首次访问：验证账户密码
   - 服务端验证后：生成`Token`返回给客户端 用js将其存储在`Cookie 或 LocalStorage`（Token 通常由接口返回在响应体里，需要 JS 自己决定存放位置）
   - 客户端保存 Token，访问需要认证的接口时在 `URL 参数`或 `HTTP Header` 中加入 Token
   - 服务端通过解码 Token 进行鉴权
     - `JWT（JSON Web Token）`：一种 Token 格式标准，由 IETF RFC 7519 定义
     - 结构三部份：header.payload.signature
     - header：算法、类型 ｜ payload：数据（用户ID、过期时间等）｜ signature：签名，防篡改
     - `Authorization`（认证/授权）是 `HTTP请求头部（Header）`中的一个字段，常用于携带用户凭证信息
     - `access_token（短期）`：避免泄露风险（即使被盗，几分钟后也过期了）｜ 每次 API 请求都要带
     - `refresh_token（长期）`：只在 access_token 过期时使用，换取新的 access_token ｜ 存储在安全的位置，不随请求频繁发送
---
## CDN 缓存的理解
`CDN（Content Delivery Network，内容分发网络）` 是一种通过在网络边缘部署`缓存服务器`来`加速内容传输`的网络架构

CDN = 反向代理服务器（`Reverse Proxy`） + 缓存（`Cache`）
- 正向代理：代表客户端向服务端发送请求 隐藏客户端身份
- 反向代理：代表服务端接收客户端请求 隐藏服务端身份
1. 提高访问速度：用户从最近的节点获取内容 减少延迟
2. 提高可用性和稳定性：分散流量 减少单点故障
3. 降低源站压力：缓存热点资源 减少服务器负载
4. **工作原理：**
  - **节点分布**：CDN 在全球或特定地区部署多个节点（缓存服务器）｜ 通常部署在离用户近、网络状况好的地方（比如 ISP 机房）
  - **用户请求重定向**：当用户访问网站内容时，`DNS` 或`负载均衡系统`将请求指向距离用户最近且可用的 `CDN` 节点 ｜ 如果节点缓存中有资源，直接返回；否则从源站拉取并缓存
  - **缓存机制**：静态资源（如图片、JS、CSS、视频等）优先缓存；可以配置缓存策略，如：缓存过期时间（TTL）
 ｜ Cache-Control / Expires 头 ｜ 强制刷新（Purge）
  - **动态内容加速**：对于动态请求，部分 CDN 支持智能路由、压缩、TCP/HTTP 优化，减少传输延迟
5. `CDN` 涉及多个网络层次，但核心功能主要运行在`应用层`
   - CDN 的主要功能（内容缓存、HTTP/HTTPS 加速、动态内容路由）都发生在`应用层`
   - CDN 节点通常会优化 `TCP` 或 `QUIC 连接（基于 UDP 的传输层协议）` (`传输层`)
   - CDN 通过智能路由（`Anycast`、`DNS 负载均衡`）把用户请求导向最近节点（`Anycast` 等技术依赖 `IP 路由`，是`网络层`优化）
- [CDN流程图解](../static/1计算机网络相关/CDN.png)
---
## 在浏览器里敲下网址并回车 —> 页面呈现
`DNS（Domain Name System，域名系统）`= “互联网电话簿” | 把`域名（www.example.com）`解析成`IP 地址（93.184.216.34 或 IPv6）`

**在浏览器里敲下网址并回车”到页面呈现**:
- URL 解析与策略检查
  - 浏览器解析你输入的是搜索词还是 URL
  - 检查 `HSTS`（该站点是否强制 `HTTPS`），有则直接走 `HTTPS`
  - 对导航请求，可能先查 Service Worker（若该站点已安装），看是否有离线/拦截逻辑
- 缓存层与本地命中
  - 浏览器可能先查自身缓存 如果是同一 `URL` 且未过期，可能直接命中
  - 但要发起网络请求前，仍需知道`目标 IP` —— 进入 `DNS 解析`
- DNS 解析
  - 先查 `浏览器DNS缓存` → `操作系统DNS缓存` → `hosts文件`（若命中直接返回）
  - 未命中则把查询交给系统配置的`递归解析器`
  - 得到 `IP` 后，结果按 `TTL`被多级缓存，后续访问更快
- 建连：TCP or QUIC + TLS
  - 若 `HTTP/3`：直接用 `QUIC（UDP）` 建连并握手 `TLS`（通常 1-RTT，甚至 0-RTT 复用历史密钥）
  - 若 `HTTP/2（或 HTTP/1.1）`：先 `TCP` 三次握手，再 `TLS` 握手。
- 发送 HTTP 请求
  - 包括 `方法（GET/POST）`、`路径`、`请求头（Host、Accept、Cookie、User-Agent、Authorization 等）`
  - 若命中 `CDN`/`反向代理`，会在边缘层处理缓存、回源、压缩（Gzip/Brotli）、图片自适应、WAF 检查等
- 服务器侧处理
  - 入口通常是 `L4/L7 负载均衡器` 或 `CDN 边缘节点`
  - 没有缓存就回源到应用（Nginx/Envoy→应用→数据库/缓存/服务网格）
  - 生成`响应头`与`响应体（HTML/CSS/JS/JSON/图片/视频…）`，带上`缓存策略、CORS、Cookie、Set-Cookie`等。
- 响应传输与浏览器渲染
  - 浏览器收响应：若是 `HTML`：开始构建 `DOM`；遇到 `<link>` 并行拉取 `CSS` 构建 `CSSOM`；合成 `Render Tree` → `Layout（布局）`→ `Paint（绘制）`→ `Composite（合成）`
  - `<script>` 可能阻塞解析（取决于 defer/async）；`preload/preconnect` 可优化关键资源加载；`HTTP/2` 多路复用/优先级调度提升性能
  - `Service Worker` 可能缓存资源、离线回退
  - 页面展现：后续交互可能有更多异步请求（XHR/Fetch/WebSocket…）
- 【补充】`DNS负载均衡（DNS Load Balancing）`是什么？
  - 定义：在权威 DNS 层面，为同一个域名返回多个可能的 IP/目标，并按某种策略（轮询、权重、地理、时延等）“分配流量”，让用户就近/均衡地访问不同服务器或边缘节点
---