# 💻 计算机网络相关
---
## HTTP 和 HTTPS
客户端（浏览器等）和服务器传输数据的协议（应用层协议）
* `HTTP（HyperText Transfer Protocol）`：明文传输 无加密 基于 TCP/IP 默认端口 80 
* `HTTPS （HyperText Transfer Protocol Secure）`：+SSL/TLS 协议 需从权威机构申请SSL证书 默认443端口
* `SSL （Secure Sockets Layer 安全套接字层）`已被 `TLS（Transport Layer Security 传输层安全协议）`取代
* `TLS（Transport Layer Security）是 SSL` 的标准化版本，由 IETF（互联网工程任务组）在 1999 年推出，基于 SSL 3.0 改进，并命名为 TLS 1.0（避免法律问题）：`机密性：加密传输` `完整性：防篡改` `身份验证`
* HTTPS 封装过程：生成原始数据 SSL/TLS 加密 并添加数字验证 ｜ 传输层 TCP 将加密后的数据分段 并添加端口号 ｜ 网络层 IP 添加源/目标 ip 地址 通过路由器传输
* `TCP（Transmission Control Protocol 传输控制协议）`传输层协议，确保数据可靠、有序地传输（HTTP/HTTPS 均依赖 TCP）
`IP（Internet Protocol 网际协议） 网络层协议`，负责数据包的路由和寻址（如 IP 地址）
---
## HTTP/1.1 和 HTTP/2
`超文本传输协议` 万维网的基础通信协议
- `0.9` 第一个协议版本 简单的网页传输 仅支持 GET 请求 明文 单向
- `1.0` 开始支持复杂的应用场景 引入 `HTTP头部` 增加`状态码` 每次请求都重新建立 `TCP连接` 传输完成后关闭
- `1.1` 目前最广泛
  - 持久连接 | `一个TCP连接`上 发送`多个HTTP请求和响应` 避免每次请求重新连接
  - 管道化 | 客户端发送请求后 不必等待响应 可以继续发下一个请求
  - 分块传输编码 | 适合内容动态生成
  - 虚拟主机支持 | 通过`host头部`支持虚拟主机 多个域名共享一个 IP 地址
- 【缺点】队头阻塞 | 虽支持持久连接：但`同一时间`只能处理`一个请求` 即使管道化：响应顺序限制 —> 阻塞
- 【缺点】多连接占用资源 ｜ 为提升性能`浏览器同一域名`打开`多个TCP连接`（通常是6个）
- `2` 基于 SPDY 协议开发设计
  - 二进制格式代替1.1的纯文本格式
  - 一个 TCP 连接同时发送多个请求和响应 且互不干扰
  - 一个请求和响应 看作一个数据流 流中数据分割成多个帧（交错发送 根据流标识重新组装）
  - HPACK 算法对首部信息压缩（`Cookie` `User-Agent` 等 1.1是重复发送 2是增量更新）
  - 支持服务器主动向客户端推送资源 即使客户端未请求 （减少延迟 提高加载速度）
  - 不强制加密 但主流浏览器只支持通过`https`使用`http/2`
---
## HTTP 请求方法
HTTP Request Methods ：`客户端 => 服务器` 发送请求时操作指令
* `GET` 请求获取制定资源 数据通过 URL 传递
* `POST` 向服务器提交数据 数据通过请求体 Body 传输 支持加密与大数据
* `DELETE` 删除指定资源
* `PUT` 更新或替换资源（全量更新）提供完整资源数据 如不存在 可能创建
* `PATCH` 对资源部分更新（增量更新） 仅发送需要修改的字段
* `...`
  * 幂等性: 重要接口（如支付）应设计为幂等（如用 PUT 替代 
  * 安全性: GET 请求参数会暴露在 URL 中，敏感数据需用 POST+HTTPS
  * 语义化: 遵循 RESTful 规范，避免滥用 POST 替代其他方法。
---
## HTTP 状态码
第一位代表响应类别：
* `1xx` 信息响应 信息已被接收 继续处理		
  * 100 继续 ｜ 101 切换协议
* `2xx` 成功响应 请求已处理
  * 200 OK 成功 ｜ 201 Created 已创建 ｜ 204 No Content 无内容 如 DELETE 成功
* `3xx` 重定向响应 请求需要进一步操作		
  * 301 永久重定向 浏览器会缓存 ｜ 302 临时重定向 资源临时移至新 URL
* `4xx` 客户端错误 请求有误 服务器无法处理
  * 400 错误 请求语法错误等 ｜ 401 未授权 如需身份认证需登录等 ｜ 403 禁止访问 权限不足等 ｜404 未找到
* `5xx` 服务器错误 服务器处理请求出错		
  * 500 服务器内部错误 ｜ 503 服务不可用 服务器维护等
---
## WebSocket
`全双工通信协议` 允许客户端与服务器建立持久连接 双向实时数据交换 一次握手长期保持连接（除非主动关闭）｜本质上是运行在`应用层`
* 底层传输依赖 TCP`(传输层)` 、是 HTTP 的补充
* HTTP: 短连接 单向 ｜WebSocket: 长连接 双向
* 1 握手阶段：通过 http 协议发起 客户端发起升级请求 服务器同意升级后返回 101 `Sec-WebSocket-Key（客）`和 `Sec-WebSocket-Accept（服）`用于验证握手
* 2 数据传输阶段：握手完成 数据以`帧`的形式传输
  * 文本帧（UTF-8） ｜ 二进制帧（图片/音频等） ｜ 控制帧（管理连接）
* 局限性：连接保持开销 占用服务器资源 ｜ 基于 HTTP/1.1 无法复用 HTTP/2.2 多路复用
* 替代方案：`SSE（Server-Sent-Events）` `长轮询（Long Poilling）`
---
## SSE 和 Long Poilling
* SSE | Server-Sent-Events｜`应用层协议`
  * 基于 HTTP 单向通道：服务端 => 客户端 实时推送数据技术 数据格式简单（纯文本或 JSON）:
    * 客户端通过 HTTP 请求向服务器订阅
    * 服务器保持连接不断开，持续发送事件数据
    * 数据格式是纯文本，通常是 UTF-8 编码的 text/event-stream
    * 天生支持自动重连和事件 ID（浏览器原生支持）
  * 工作流程:
    - 客户端用 EventSource API 发起 GET 请求
    - 服务器设置 Content-Type: text/event-stream，然后一直写数据
    - 浏览器解析每条 event: xxx\ndata: yyy\n\n 格式的消息，并触发监听器
* Long Poilling | 长轮询｜`应用层协议`
  * 客户端发起一个 HTTP 请求，服务器不立即响应，而是等到有数据时才返回 | 模拟双向实时 通过 HTTP 请求“挂起”实现低延迟 | 工作流程：
    * 客户端发送请求
    * 服务器保持请求不返回，直到有新数据才返回
    * 客户端立即发起下一次请求
    * 重复以上
---
## 三次握手与四次挥手
`TCP协议`：传输层（Transport Layer）为应用层（HTTP、FTP、SMTP 等）提供`可靠的`、`面向连接的`、`端到端的`字节流传输服务 ｜ 三次挥手：确立连接 四次挥手：终止连接 ｜ 传输过程中使用`确认机制`、`重传机制`、`流量控制`和`拥塞控制`来保证数据的可靠性

【 传输层：`段 Segment`｜应用层：`消息 Message`｜TCP 把应用层交下来的数据看作没有边界的`字节序列 Byte Stream`｜UDP 则面向`报文 Message Oriented` 】

双方就各自的初始序列号（ISN）达成共识，并确认“我能收发、你也能收发” `SYN`:同步序列号 `ACK`:确认
- `TCP服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了 `LISTEN 监听状态`
- `第一次握手` `TCP客户进程`也是先创建`传输控制块TCB`，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 `SYN-SENT 同步已发送状态`
- `第二次握手` TCP服务器收到请求报文后，如果同意连接，则会向客户端发出`确认报文`。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 `SYN-RCVD 同步收到状态`
- `第三次握手` TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入`ESTABLISHED已建立连接状态` 触发三次握手
  - 为什么要进行第三次握手？：主要原因：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误
  - 第一次握手： 客户端向服务器端发送报文 证明客户端的发送能力正常
  - 第二次握手：服务器端接收到报文并向客户端发送报文 证明服务器端的接收能力、发送能力正常
  - 第三次握手：客户端向服务器发送报文 证明客户端的接收能力正常

TCP 是全双工的，两个方向各自独立关闭，需要各自 `FIN`/`ACK` 一对，因此通常是四次: `FIN:发送方不再发送数据（但仍可收）` `ACK:确认`
- 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于`ESTABLISHED状态`，然后客户端主动关闭，服务器被动关闭
- `第一次挥手` 客户端发出`连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（=前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入`FIN-WAIT-1 终止等待1`状态
- `第二次挥手` 服务器端接收到`连接释放报文`后，发出`确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了`CLOSE-WAIT 关闭等待状态`
- `第三次挥手` 客户端接收到服务器端的确认请求后，客户端就会进入`FIN-WAIT-2 终止等待2`状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送`连接释放报文`，服务器就进入了`LAST-ACK 最后确认`状态，等待客户端的确认
- `第四次挥手` 客户端收到服务器的`连接释放报文`后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了`TIME-WAIT 时间等待状态`，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当`客户端撤销相应的TCB`后，客户端才会进入`CLOSED关闭状态`，服务器端接收到`确认报文`后，会立即进入`CLOSED关闭状态`，到这里TCP连接就断开了，四次挥手完成
  - 为什么客户端要等待`2MSL`？:主要原因是为了保证客户端发送那个的`第一个ACK报文能到到服务器`，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文
---
## Cookie Session Token｜HTTP协议层的状态管理与认证机制
---
## 对浏览器内核的理解
